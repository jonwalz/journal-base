# AI-Assisted Coding Security Best Practices (Vibe Coding Security)

## Introduction

When using AI assistants (like Cursor, GitHub Copilot, etc.) or "vibe coding" methodologies to generate significant portions of application code (e.g., 80%), security vulnerabilities can be easily introduced if not actively managed. Blindly trusting AI-generated code is risky. This document outlines key security areas and best practices to consider, based on common pitfalls. Remember that developers are ultimately responsible for the security of the code, even if generated by AI.

## Core Security Principles:

1.  **Verify AI Output:** Always review and understand code generated by AI, especially concerning security, data handling, and external interactions.
2.  **Layered Security:** Implement security measures at multiple levels (client, server, database).
3.  **Principle of Least Privilege:** Grant users and services only the minimum permissions necessary to perform their functions.

## Specific Security Practices:

### 1. Rate Limiting

- **Concept:** Restricting the number of requests a user or IP address can make to API endpoints within a specific time window.
- **Risk Mitigated:** Denial-of-Service (DoS) attacks, brute-force attacks, excessive resource consumption, high API costs.
- **Implementation:**
  - Use middleware libraries (e.g., `express-rate-limit` for Node.js/Express).
  - Configure reasonable limits (e.g., requests per minute/hour) based on expected usage.
  - Apply globally to all relevant API routes.
  - Consider stricter limits for sensitive or resource-intensive operations (e.g., login, password reset, AI chat generation).
  - Return appropriate HTTP status codes (e.g., 429 Too Many Requests) when limits are exceeded.

### 2. API Key / Secret Management

- **Concept:** Securely storing and handling sensitive credentials like API keys, database passwords, and private tokens.
- **Risk Mitigated:** Unauthorized access to third-party services, data breaches, account takeover, financial loss.
- **Implementation:**
  - **NEVER** hardcode secrets directly into source code (client-side OR server-side).
  - **NEVER** expose server-side API keys or full-access database keys to the client-side (browser/app).
  - Use environment variables (`.env` files) to store secrets on the server.
  - Utilize secrets management tools provided by hosting platforms (e.g., Vercel Environment Variables, Replit Secrets, AWS Secrets Manager, Google Secret Manager).
  - Ensure `.env` files (containing actual secrets) are listed in your `.gitignore` file to prevent accidental commits to version control.
  - Use separate, restricted keys for client-side use if absolutely necessary (e.g., Supabase anonymous key, Google Maps public key), understanding their limitations.

### 3. Backend Data Validation & Sanitization

- **Concept:** Rigorously checking and cleaning all data received by the backend API before processing or storing it.
- **Risk Mitigated:** SQL injection, Cross-Site Scripting (XSS), data corruption, unexpected application behavior, bypassing business logic.
- **Implementation:**
  - **DO NOT** trust client-side validation alone; it can be easily bypassed. Implement validation on the server/backend.
  - Use validation libraries (e.g., Zod, Joi, Yup) to define expected data schemas (types, formats, ranges, allowed values).
  - Validate data types, lengths, formats (e.g., email, URL), and allowed characters.
  - Sanitize input to remove potentially harmful scripts or code before storing or displaying it.
  - Reject requests with invalid or unexpected data early in the processing pipeline.

### 4. Database Access Control (Row Level Security - RLS)

- **Concept:** Implementing database-level rules that restrict which rows users can query or modify based on their identity or role.
- **Risk Mitigated:** Unauthorized access to or modification of other users' data within the same table.
- **Implementation:**
  - Utilize built-in database features (e.g., Supabase RLS, Firebase Security Rules, PostgreSQL Policies).
  - Enable RLS for tables containing user-specific data.
  - Define policies based on the authenticated user's ID (e.g., `auth.uid() = user_id`).
  - Ensure policies cover all relevant operations (SELECT, INSERT, UPDATE, DELETE).
  - Test policies thoroughly.

### 5. Spam/Bot Protection

- **Concept:** Implementing mechanisms to prevent automated bots from submitting forms or interacting with endpoints maliciously.
- **Risk Mitigated:** Database flooding with spam, fake account creation, resource exhaustion.
- **Implementation:**
  - Use CAPTCHA services (e.g., Google reCAPTCHA, hCaptcha) on public forms (signup, login, contact).
  - Consider "honeypot" fields (hidden fields that only bots would fill).
  - Implement rate limiting (see point 1) on form submission endpoints.

### 6. Dependency Management

- **Concept:** Being mindful of the third-party libraries (NPM packages, etc.) introduced by AI or manually.
- **Risk Mitigated:** Vulnerabilities in outdated or malicious dependencies, unnecessary code bloat increasing attack surface.
- **Implementation:**
  - Regularly review project dependencies.
  - Use tools to scan for known vulnerabilities (e.g., `npm audit`, Snyk).
  - Keep dependencies updated to patched versions.
  - Remove unused or redundant libraries promptly. Verify if the AI installed a library that duplicates existing functionality.

### 7. Data Encryption (Sensitive Information)

- **Concept:** Encrypting sensitive user data _before_ storing it in the database (encryption at rest).
- **Risk Mitigated:** Exposure of sensitive personal information (PII) if the database itself is compromised. Enhances user privacy.
- **Implementation:**
  - Identify sensitive data fields (e.g., chat messages, journal entries, personal notes).
  - Use standard, strong encryption libraries (e.g., Node.js `crypto` module).
  - Implement encryption/decryption logic on the server-side.
  - **Crucially:** Use a per-user encryption key derived securely (e.g., from user password via a strong KDF like Argon2, or a securely stored unique key per user). Store this key securely and _never_ in plain text alongside the encrypted data. Hashing passwords is for authentication; _encryption_ is for protecting data confidentiality.
  - Ensure only the intended user (with their key) can decrypt their specific data.

### 8. Monitoring and Logging

- **Concept:** Actively tracking application behavior, errors, and access patterns through logs.
- **Risk Mitigated:** Undetected errors, inability to diagnose issues, unawareness of security incidents or suspicious activity.
- **Implementation:**
  - Utilize logging capabilities of your hosting platform (e.g., Vercel, Supabase, AWS CloudWatch).
  - Log important events, errors, and potentially suspicious activities (e.g., failed logins, RLS violations, rate limit triggers).
  - Regularly review logs to identify anomalies or errors.
  - Consider using user behavior analytics tools (like Hotjar) cautiously, ensuring PII is masked/anonymized according to privacy regulations.

## Conclusion

AI-assisted coding accelerates development but requires increased diligence regarding security. Regularly apply these principles, review generated code critically, and prioritize secure practices throughout the development lifecycle. Assume vulnerabilities exist until proven otherwise.
